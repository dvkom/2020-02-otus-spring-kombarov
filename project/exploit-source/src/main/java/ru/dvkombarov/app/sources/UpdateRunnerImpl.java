package ru.dvkombarov.app.sources;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import ru.dvkombarov.app.configuration.CommonConfig;
import ru.dvkombarov.app.sources.exploits.ExploitSourceService;
import ru.dvkombarov.app.sources.vulners.VulnersSourceService;

import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

@Service
public class UpdateRunnerImpl implements UpdateRunner {

  private final List<ExploitSourceService> exploitSourceServices;

  private final VulnersSourceService vulnersSourceService;

  private final CommonConfig config;

  private static final Logger LOG = LoggerFactory.getLogger(UpdateRunnerImpl.class);

  public UpdateRunnerImpl(List<ExploitSourceService> exploitSourceServices,
                          VulnersSourceService vulnersSourceService,
                          CommonConfig config) {
    this.exploitSourceServices = exploitSourceServices;
    this.vulnersSourceService = vulnersSourceService;
    this.config = config;
  }

  @Override
  @Scheduled(cron = "${common.cron}")
  public void updateFromSources() {
    ExecutorService executorService = Executors.newFixedThreadPool(config.getThreadCount());
    exploitSourceServices.forEach(service -> executorService.execute(service::updateExploits));
    executorService.execute(vulnersSourceService::updateVulners);
    LOG.info("Updating exploits and vulners have started");
    executorService.shutdown();
    try {
      if (!executorService.awaitTermination(3, TimeUnit.MINUTES)) {
        executorService.shutdownNow();
      }
    } catch (InterruptedException e) {
      executorService.shutdownNow();
    } finally {
      LOG.info("Updating exploits and vulners have finished");
    }
  }
}

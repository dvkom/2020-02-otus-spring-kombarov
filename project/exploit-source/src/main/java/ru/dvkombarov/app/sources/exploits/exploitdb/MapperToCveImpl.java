package ru.dvkombarov.app.sources.exploits.exploitdb;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import ru.dvkombarov.app.domain.Exploit;
import ru.dvkombarov.app.domain.Vulnerability;
import ru.dvkombarov.app.repository.VulnerabilityRepository;

import java.util.*;

@Component
public class MapperToCveImpl implements MapperToCve {

  private static final Logger LOG = LoggerFactory.getLogger(MapperToCveImpl.class);

  private final VulnerabilityRepository vulnerabilityRepository;

  public MapperToCveImpl(VulnerabilityRepository vulnerabilityRepository) {
    this.vulnerabilityRepository = vulnerabilityRepository;
  }

  @Override
  public List<Exploit> createExploits(List<Exploit> exploits,
                                      Map<String, List<String>> mapToCve) {
    LOG.info("Mapping to CVE started");
    List<Exploit> mappedExploits = new ArrayList<>();

    if (exploits != null && mapToCve != null) {
      for (Exploit exploit : exploits) {
        String sourceId = exploit.getId().getSourceId();
        List<String> cveNumbers = mapToCve.get(sourceId);
        if (cveNumbers != null) {
          Set<Vulnerability> vulnerabilities = findVulnerabilitiesByCves(cveNumbers);
          Exploit mappedExploit = new Exploit(exploit);
          mappedExploit.setVulnerabilities(vulnerabilities);
          mappedExploits.add(mappedExploit);
        }
      }
    }

    LOG.info("Mapping to CVE finished, {} exploits created", mappedExploits.size());

    return mappedExploits;
  }

  private Set<Vulnerability> findVulnerabilitiesByCves(List<String> cveNumbers) {
    Set<Vulnerability> vulnerabilities = new HashSet<>();
    for (String cve : cveNumbers) {
      Vulnerability vulnerability = vulnerabilityRepository
          .findVulnerabilityByCve(cve)
          .orElse(new Vulnerability(cve, ""));
      vulnerabilities.add(vulnerability);
    }

    return vulnerabilities;
  }
}

package ru.dvkombarov.app.sources.vulners;

import org.apache.commons.lang3.exception.ExceptionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;
import ru.dvkombarov.app.configuration.VunlersSourceConfig;
import ru.dvkombarov.app.constants.SourceType;
import ru.dvkombarov.app.constants.UpdateStatus;
import ru.dvkombarov.app.domain.UpdateInfo;
import ru.dvkombarov.app.domain.Vulnerability;
import ru.dvkombarov.app.repository.UpdateInfoRepository;
import ru.dvkombarov.app.repository.VulnerabilityJdbcRepository;
import ru.dvkombarov.app.sources.exploits.exploitdb.LastUpdateDateHtmlParser;

import java.io.InputStream;
import java.net.URL;
import java.time.LocalDate;
import java.util.List;

@Component
public class VulnersSourceServiceImpl implements VulnersSourceService {
  private static final Logger LOG = LoggerFactory.getLogger(VulnersSourceServiceImpl.class);

  private final LastUpdateDateHtmlParser lastUpdateDateHtmlParser;

  private final VulnersReader vulnersReader;

  private final VulnerabilityJdbcRepository vulnerabilityJdbcRepository;

  private final UpdateInfoRepository updateInfoRepository;

  private final VunlersSourceConfig config;

  public VulnersSourceServiceImpl(@Qualifier("vulnersDateParser") LastUpdateDateHtmlParser lastUpdateDateHtmlParser,
                                  VulnersReader vulnersReader,
                                  VulnerabilityJdbcRepository vulnerabilityJdbcRepository,
                                  UpdateInfoRepository updateInfoRepository,
                                  VunlersSourceConfig config) {
    this.lastUpdateDateHtmlParser = lastUpdateDateHtmlParser;
    this.vulnersReader = vulnersReader;
    this.vulnerabilityJdbcRepository = vulnerabilityJdbcRepository;
    this.updateInfoRepository = updateInfoRepository;
    this.config = config;
  }

  @Override
  public void updateVulners() {
    if (isUpdatesAvailable()) {
      try (InputStream inputStream = new URL(config.getCveDownloadUrl()).openStream()) {
        List<Vulnerability> vulnerabilities = vulnersReader.readVulners(inputStream);

        if (!CollectionUtils.isEmpty(vulnerabilities)) {
          LOG.info("Saving vulners into DB started");
          vulnerabilityJdbcRepository.saveAll(vulnerabilities);
          updateInfoRepository.save(
              new UpdateInfo(SourceType.VULNERS, UpdateStatus.SUCCESS, LocalDate.now())
          );
          LOG.info("Saving vulners into DB finished");
        }

        LOG.info(String.format("Update is complete. %d vulners saved", vulnerabilities.size()));
      } catch (Exception e) {
        LOG.error("Error updating vulners:", e);
        updateInfoRepository.save(new UpdateInfo(
            SourceType.VULNERS, UpdateStatus.ERROR,
            LocalDate.now(), ExceptionUtils.getStackTrace(e))
        );
      }
    } else {
      LOG.info("No vulners updates available");
    }
  }

  private boolean isUpdatesAvailable() {
    LocalDate lastUpdateDate = getLastUpdateDate();
    LocalDate sourceUpdateDate = lastUpdateDateHtmlParser.parseDateFromDocument();
    LOG.info("Last update date: {}; vulners source update date: {}",
        lastUpdateDate, sourceUpdateDate
    );

    return sourceUpdateDate.isAfter(lastUpdateDate);
  }

  private LocalDate getLastUpdateDate() {
    return updateInfoRepository.getLastUpdateDateTime(SourceType.VULNERS, UpdateStatus.SUCCESS)
        .orElse(LocalDate.now().minusMonths(1L));
  }
}

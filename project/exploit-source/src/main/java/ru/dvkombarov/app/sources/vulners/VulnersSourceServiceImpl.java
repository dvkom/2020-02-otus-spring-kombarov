package ru.dvkombarov.app.sources.vulners;

import org.apache.commons.lang3.exception.ExceptionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;
import ru.dvkombarov.app.constants.SourceType;
import ru.dvkombarov.app.constants.UpdateStatus;
import ru.dvkombarov.app.dao.service.UpdateInfoService;
import ru.dvkombarov.app.dao.service.VulnerService;
import ru.dvkombarov.app.domain.UpdateInfo;
import ru.dvkombarov.app.domain.Vulnerability;
import ru.dvkombarov.app.sources.LastUpdateDateHtmlParser;

import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeParseException;
import java.util.List;

@Component
public class VulnersSourceServiceImpl implements VulnersSourceService {
  private static final Logger LOG = LoggerFactory.getLogger(VulnersSourceServiceImpl.class);

  private final LastUpdateDateHtmlParser lastUpdateDateHtmlParser;

  private final VulnersReader vulnersReader;

  private final VulnerService vulnerService;

  private final UpdateInfoService updateInfoService;

  public VulnersSourceServiceImpl(@Qualifier("vulnersDateParser") LastUpdateDateHtmlParser lastUpdateDateHtmlParser,
                                  VulnersReader vulnersReader,
                                  VulnerService vulnerService,
                                  UpdateInfoService updateInfoService) {
    this.lastUpdateDateHtmlParser = lastUpdateDateHtmlParser;
    this.vulnersReader = vulnersReader;
    this.vulnerService = vulnerService;
    this.updateInfoService = updateInfoService;
  }

  @Override
  public void updateVulners() {
    if (isUpdatesAvailable()) {
      try {
        List<Vulnerability> vulnerabilities = vulnersReader.readVulners();

        if (!CollectionUtils.isEmpty(vulnerabilities)) {
          LOG.info("Saving vulners into DB started");
          vulnerService.saveAll(vulnerabilities);
          updateInfoService.save(
              new UpdateInfo(SourceType.VULNERS, UpdateStatus.SUCCESS, LocalDate.now())
          );
          LOG.info("Saving vulners into DB finished");
        }

        LOG.info(String.format("Update is complete. %d vulners saved", vulnerabilities.size()));
      } catch (Exception e) {
        LOG.error("Error updating vulners:", e);
        updateInfoService.save(new UpdateInfo(
            SourceType.VULNERS, UpdateStatus.ERROR,
            LocalDate.now(), ExceptionUtils.getStackTrace(e))
        );
      }
    } else {
      LOG.info("No vulners updates available");
    }
  }

  private boolean isUpdatesAvailable() {
    LocalDate lastUpdateDate = updateInfoService.getLastUpdateDate(
        SourceType.VULNERS, UpdateStatus.SUCCESS
    );
    LocalDate sourceUpdateDate = LocalDate.now();
    try {
      sourceUpdateDate = lastUpdateDateHtmlParser.parseDateFromDocument();
      LOG.info("Last update date: {}; vulners source update date: {}",
          lastUpdateDate, sourceUpdateDate
      );
    } catch (DateTimeParseException | StringIndexOutOfBoundsException | IOException e) {
      LOG.error("Error parsing vulners update date, the default value (today) is used ", e);
    }

    return sourceUpdateDate.isAfter(lastUpdateDate);
  }
}

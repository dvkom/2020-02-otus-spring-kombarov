package ru.dvkombarov.app.sources.exploits.exploitdb;

import org.apache.commons.lang3.exception.ExceptionUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;
import ru.dvkombarov.app.constants.SourceType;
import ru.dvkombarov.app.constants.UpdateStatus;
import ru.dvkombarov.app.dao.service.ExploitService;
import ru.dvkombarov.app.dao.service.UpdateInfoService;
import ru.dvkombarov.app.domain.Exploit;
import ru.dvkombarov.app.domain.UpdateInfo;
import ru.dvkombarov.app.sources.LastUpdateDateHtmlParser;
import ru.dvkombarov.app.sources.exploits.ExploitSourceService;

import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeParseException;
import java.util.List;
import java.util.Map;

@Service
public class ExploitDbSourceService implements ExploitSourceService {

  private static final Logger LOG = LoggerFactory.getLogger(ExploitDbSourceService.class);

  private final LastUpdateDateHtmlParser lastUpdateDateHtmlParser;

  private final ExploitsReader exploitsReader;

  private final MapToCveExtractor mapToCveExtractor;

  private final MapperToCve mapperToCve;

  private final ExploitService exploitService;

  private final UpdateInfoService updateInfoService;

  public ExploitDbSourceService(@Qualifier("exploitsDateParser") LastUpdateDateHtmlParser lastUpdateDateHtmlParser,
                                ExploitsReader exploitsReader,
                                MapToCveExtractor mapToCveExtractor,
                                MapperToCve mapperToCve,
                                ExploitService exploitService,
                                UpdateInfoService updateInfoService) {
    this.lastUpdateDateHtmlParser = lastUpdateDateHtmlParser;
    this.exploitsReader = exploitsReader;
    this.mapToCveExtractor = mapToCveExtractor;
    this.mapperToCve = mapperToCve;
    this.exploitService = exploitService;
    this.updateInfoService = updateInfoService;
  }

  @Override
  public void updateExploits() {
    if (isUpdatesAvailable()) {

      try {
        List<Exploit> downloadedExploits = exploitsReader.readExploits();
        Map<String, List<String>> mapToCve = mapToCveExtractor.extractMapToCve();
        List<Exploit> mappedExploits = mapperToCve.createExploits(downloadedExploits, mapToCve);

        if (!CollectionUtils.isEmpty(mappedExploits)) {
          LOG.info("Saving exploits into DB started");
          exploitService.saveAll(mappedExploits);
          updateInfoService.save(
              new UpdateInfo(SourceType.EXPLOITDB, UpdateStatus.SUCCESS, LocalDate.now())
          );
          LOG.info("Saving exploits into DB finished");
        }

        LOG.info(String.format("Update is complete. %d exploits saved", mappedExploits.size()));

      } catch (Exception e) {
        LOG.error("Error updating exploits:", e);
        updateInfoService.save(new UpdateInfo(
            SourceType.EXPLOITDB, UpdateStatus.ERROR,
            LocalDate.now(), ExceptionUtils.getStackTrace(e))
        );
      }
    } else {
      LOG.info("No exploit updates available");
    }
  }

  private boolean isUpdatesAvailable() {
    LocalDate lastUpdateDate = updateInfoService.getLastUpdateDate(
        SourceType.EXPLOITDB, UpdateStatus.SUCCESS
    );
    LocalDate sourceUpdateDate = LocalDate.now();
    try {
      sourceUpdateDate = lastUpdateDateHtmlParser.parseDateFromDocument();
      LOG.info("Last update date: {}; exploitsDb source update date: {}",
          lastUpdateDate, sourceUpdateDate
      );
    } catch (DateTimeParseException | StringIndexOutOfBoundsException | IOException e) {
      LOG.error("Error parsing exploits update date, the default value (today) is used. ", e);
    }

    return sourceUpdateDate.isAfter(lastUpdateDate);
  }
}
